import tkinter as tk
from tkinter import ttk, filedialog, messagebox, scrolledtext
from PIL import Image, ImageTk, ImageFilter, ImageEnhance
import numpy as np
from numpy.fft import fft2, fftshift
import matplotlib.pyplot as plt
from scipy.stats import kurtosis, skew
from scipy.signal import find_peaks
import pywt  # Python Wavelet Transform library
from skimage.feature.texture import graycomatrix, graycoprops
from tensorflow.keras.models import load_model
from tensorflow.keras.preprocessing import image
from scipy.stats import chisquare
import random

# Inițializarea ferestrei principale
app = tk.Tk()
app.title("Detector de Steganografie Avansat")

tab_control = ttk.Notebook(app)

# Crearea unui tab nou pentru încărcarea imaginilor
tab_load = ttk.Frame(tab_control)
tab_control.add(tab_load, text='Încărcare Imagine')
tab_control.pack(expand=1, fill='both')

tab_LSB = ttk.Frame(tab_control)
tab_histogram = ttk.Frame(tab_control)
tab_fourier = ttk.Frame(tab_control)
tab_wavelet = ttk.Frame(tab_control)
tab_texture = ttk.Frame(tab_control)
tab_malware = ttk.Frame(tab_control)

tab_control.add(tab_LSB, text='Analiza LSB')
tab_control.add(tab_histogram, text='Analiza Histogramă')
tab_control.add(tab_fourier, text='Analiza Fourier')
tab_control.add(tab_wavelet, text='Analiza Wavelet')
tab_control.add(tab_texture, text='Analiza Texturii')
tab_control.add(tab_malware, text='Analiza Malware')
tab_control.pack(expand=1, fill='both')

result_text = tk.StringVar()
panel = tk.Label(tab_load)
panel.pack(padx=10, pady=10)

# Panouri de raport pentru fiecare tab
lsb_report = scrolledtext.ScrolledText(tab_LSB, wrap=tk.WORD, height=10)
lsb_report.pack(fill=tk.BOTH, expand=True)

histogram_report = scrolledtext.ScrolledText(tab_histogram, wrap=tk.WORD, height=10)
histogram_report.pack(fill=tk.BOTH, expand=True)

fourier_report = scrolledtext.ScrolledText(tab_fourier, wrap=tk.WORD, height=10)
fourier_report.pack(fill=tk.BOTH, expand=True)

wavelet_report = scrolledtext.ScrolledText(tab_wavelet, wrap=tk.WORD, height=10)
wavelet_report.pack(fill=tk.BOTH, expand=True)

texture_report = scrolledtext.ScrolledText(tab_texture, wrap=tk.WORD, height=10)
texture_report.pack(fill=tk.BOTH, expand=True)

# Funcții pentru raport
def update_report(report_panel, info):
    report_panel.insert(tk.END, info + "\n")

# Funcția de validare a imaginii
def is_valid_image(file_path):
    try:
        img = Image.open(file_path)
        img.verify()
        return True
    except Exception:
        return False

# Încărcarea imaginii
def load_image():
    file_path = filedialog.askopenfilename()
    if file_path and is_valid_image(file_path):
        img = Image.open(file_path)
        img.thumbnail((300, 300))
        tk_image = ImageTk.PhotoImage(img)
        panel.configure(image=tk_image)
        panel.image = tk_image  # Keep a reference!
        panel.file_path = file_path
        result_text.set("Imagine încărcată. Selectați o analiză.")
        lsb_report.delete('1.0', tk.END)
        histogram_report.delete('1.0', tk.END)
        fourier_report.delete('1.0', tk.END)
        wavelet_report.delete('1.0', tk.END)
        texture_report.delete('1.0', tk.END)
    else:
        messagebox.showerror("Eroare", "Fișier invalid sau corupt.")

def analyze_LSB(image_path, sample_fraction=0.2, seed=42):
    try:
        random.seed(seed)
        np.random.seed(seed)

        img = Image.open(image_path)
        pixels = np.array(img)
        total_pixels = np.prod(pixels.shape[:2])
        sample_size = max(int(total_pixels * sample_fraction), 1000)  # Asigurăm un minim de 1000 pixeli

        sampled_indices = np.random.choice(total_pixels, sample_size, replace=False)
        sampled_pixels = pixels.reshape(-1, 3)[sampled_indices]

        lsb_counts = {i: np.bincount(np.bitwise_and(sampled_pixels[:, i], 1), minlength=2) for i in range(3)}
        detected = False

        lsb_report_content = "Analiza LSB:\n"
        for i, color in enumerate(["Roșu", "Verde", "Albastru"]):
            observed = lsb_counts[i]
            # Ajustează frecvențele așteptate pentru a reflecta dimensiunea reală a eșantionului
            expected = [sample_size / 2, sample_size / 2] if sample_size % 2 == 0 else [(sample_size // 2) + 1, sample_size // 2]
            chi2, p = chisquare(observed, f_exp=expected)

            lsb_report_content += f" - Canalul {color}: {observed[0]} '0', {observed[1]} '1' (chi2={chi2:.2f}, p={p:.3f})\n"
            if p < 0.05:  # Considerăm un prag de semnificație de 5%
                detected = True

        lsb_report_content += "Steganografie detectată" if detected else "Nicio steganografie detectată"
        update_report(lsb_report, lsb_report_content)
    except Exception as e:
        messagebox.showerror("Eroare", f"Eroare la analiza LSB: {str(e)}")


def analyze_histogram(image_path):
    try:
        img = Image.open(image_path)
        if img.mode != 'L':
            img = img.convert('L')  # Asigură că imaginea este în modul lumină (grayscale)

        pixels = np.array(img)
        if pixels.size < 256:
            raise ValueError("Imaginea este prea mică pentru a realiza o analiză relevantă a histogramelor.")

        histogram, bins = np.histogram(pixels, bins=256, range=(0, 256))

        # Vizualizare folosind Matplotlib
        plt.figure(figsize=(10, 5))
        plt.bar(bins[:-1], histogram, width=bins[1] - bins[0], color='gray', edgecolor='black')

        # Calcularea și plotarea vârfurilor
        peaks, _ = find_peaks(histogram)
        plt.plot(peaks, histogram[peaks], "r^", label='Vârfuri')
        plt.title('Histograma de Intensitate')
        plt.xlabel('Valoare Intensitate')
        plt.ylabel('Număr de Pixeli')
        plt.legend()
        plt.show()

        # Calculul metricilor statistici
        data_skewness = skew(histogram)
        data_kurtosis = kurtosis(histogram)

        # Analiza și raportarea rezultatelor
        peak_report = "\nVârfuri identificate la intensități: " + ", ".join(str(peak) for peak in peaks)
        explanation = (
            f"\nSkewness: {data_skewness:.3f} (Indică o distribuție nesimetrică)\n"
            f"Kurtosis: {data_kurtosis:.3f} (Indică o prezență a vârfurilor accentuate)\n"
        )
        conclusion = "Analiza sugerează "
        if data_kurtosis > 5 and len(peaks) > 20:
            conclusion += "indicii puternice de steganografie sau manipulare a imaginii."
        elif data_kurtosis > 3 and len(peaks) > 15:
            conclusion += "indicii moderate de steganografie sau manipulare."
        else:
            conclusion += "absența indiciilor semnificative de steganografie sau manipulare."

        report_content = peak_report + explanation + "\nConcluzie: " + conclusion
        update_report(histogram_report, report_content)

    except ValueError as ve:
        messagebox.showerror("Eroare", str(ve))
    except Exception as e:
        messagebox.showerror("Eroare", f"Eroare la analiza histogramelor: {str(e)}")

def fourier_analysis(image_path):
    try:
        img = Image.open(image_path).convert('L')
        f_transform = fft2(np.array(img))
        f_shifted = fftshift(f_transform)
        magnitude_spectrum = 20 * np.log(np.abs(f_shifted) + 1)

        plt.figure(figsize=(8, 8))
        plt.imshow(magnitude_spectrum, cmap='gray')
        plt.colorbar()
        plt.title('Spectru de Magnitudine Fourier')

        # Determină pragurile pentru frecvențe înalte
        high_freq_threshold = np.mean(magnitude_spectrum) + 2 * np.std(magnitude_spectrum)
        plt.axhline(high_freq_threshold, color='r', linestyle='--', label='High Frequency Threshold')
        plt.legend()
        plt.show()

        mean_spectrum = np.mean(magnitude_spectrum)
        std_spectrum = np.std(magnitude_spectrum)
        skew_spectrum = skew(magnitude_spectrum.flatten())
        kurtosis_spectrum = kurtosis(magnitude_spectrum.flatten())

        explanation = (
            f"Fourier - Media: {mean_spectrum:.2f}, STD: {std_spectrum:.2f}, "
            f"Skew: {skew_spectrum:.2f}, Kurtosis: {kurtosis_spectrum:.2f}\n"
            "Zonele cu frecvențe înalte indică potențiale manipulări sau informații ascunse."
        )

        if std_spectrum > 2 * np.std(magnitude_spectrum):
            conclusion = "Indicii puternice de manipulare sau steganografie detectate."
        else:
            conclusion = "Nu există indicii semnificative de manipulare sau steganografie."

        update_report(fourier_report, "Analiza Fourier: " + explanation + "\nConcluzie: " + conclusion)
    except Exception as e:
        messagebox.showerror("Eroare", f"Eroare la analiza Fourier: {str(e)}")

def wavelet_analysis(image_path):
    try:
        img = Image.open(image_path).convert('L')
        coefficients = pywt.wavedec2(np.array(img), 'haar', level=3)
        cA3, (cH3, cV3, cD3) = coefficients[0], coefficients[1]

        plt.figure(figsize=(10, 10))
        plt.subplot(221), plt.imshow(cA3, cmap='gray'), plt.title('Apropiere')
        plt.subplot(222), plt.imshow(cH3, cmap='gray'), plt.title('Orizontal')
        plt.subplot(223), plt.imshow(cV3, cmap='gray'), plt.title('Vertical')
        plt.subplot(224), plt.imshow(cD3, cmap='gray'), plt.title('Diagonal')
        plt.show()

        # Calcularea energiei pentru fiecare componentă
        energy_h = np.sum(np.square(cH3))
        energy_v = np.sum(np.square(cV3))
        energy_d = np.sum(np.square(cD3))

        explanation = (
            f"Energie Orizontală: {energy_h:.2f}, "
            f"Energie Verticală: {energy_v:.2f}, "
            f"Energie Diagonală: {energy_d:.2f}\n"
            "Energia mare în componentele orizontale și diagonale poate indica manipulare sau inserție de date."
        )

        # Concluzii pe baza analizei
        if energy_d > energy_h * 2 and energy_d > energy_v * 2:
            conclusion = "Indicii puternice de manipulare sau steganografie detectate."
        else:
            conclusion = "Nu există indicii semnificative de manipulare sau steganografie."

        update_report(wavelet_report, "Analiza Wavelet: " + explanation + "\nConcluzie: " + conclusion)
    except Exception as e:
        messagebox.showerror("Eroare", f"Eroare la analiza Wavelet: {str(e)}")

def analyze_texture(image_path):
    try:
        img = Image.open(image_path).convert('L')
        pixels = np.array(img)
        g_matrix = graycomatrix(pixels, [1], [0, np.pi/4, np.pi/2, 3*np.pi/4], levels=256, symmetric=True, normed=True)
        properties = ['contrast', 'dissimilarity', 'ASM', 'energy', 'homogeneity']
        results = {prop: graycoprops(g_matrix, prop) for prop in properties}

        explanation = "Analiza Texturii:\n"
        for prop, value in results.items():
            explanation += f"{prop.title()}: {np.mean(value):.4f}\n"

        conclusion = "Detaliile texturale pot indica zone cu manipulări potențiale sau caracteristici neobișnuite ale texturii."
        update_report(texture_report, explanation + "Concluzie: " + conclusion)
    except Exception as e:
        messagebox.showerror("Eroare", f"Eroare la analiza texturii: {str(e)}")


model = load_model('high_accuracy_malware_model.keras')

class_labels = {
    0: 'Adposhel',
    1: 'Agent',
    2: 'Allaple',
    3: 'Alueron.gen!J',
    4: 'Amonetize',
    5: 'Androm',
    6: 'Autorun',
    7: 'BrowseFox',
    8: 'C2LOP.gen!g',
    9: 'Dialplatform.B',
    10: 'Dinwod',
    11: 'Elex',
    12: 'Expiro',
    13: 'Fakerean',
    14: 'Fasong',
    15: 'HackKMS',
    16: 'Hlux',
    17: 'Injector',
    18: 'InstallCore',
    19: 'Lolyda.AA1',
    20: 'Lolyda.AA2',
    21: 'MultiPlug',
    22: 'Neoreklami',
    23: 'Neshta',
    24: 'Regrun',
    25: 'Sality',
    26: 'Snarasite',
    27: 'Stantinko',
    28: 'VBA',
    29: 'VBKyrpy',
    30: 'Vilsel'
}

def predict_image(img_path, top_n=3):
    img = image.load_img(img_path, target_size=(224, 224))
    img_array = image.img_to_array(img)
    img_array = np.expand_dims(img_array, axis=0)
    img_array /= 255.0

    predictions = model.predict(img_array)[0]
    top_indices = predictions.argsort()[-top_n:][::-1]
    results = [(class_labels[index], predictions[index]) for index in top_indices]
    return results

malware_report = scrolledtext.ScrolledText(tab_malware, wrap=tk.WORD, height=10)
malware_report.pack(fill=tk.BOTH, expand=True)

def perform_malware_analysis():
    if hasattr(panel, 'file_path') and panel.file_path:
        try:
            predictions = predict_image(panel.file_path, top_n=5)
            report_content = "Rezultatele clasificării Malware:\n"
            for cls, prob in predictions:
                report_content += f"Clasa {cls} cu probabilitatea {prob*100:.2f}%\n"
            malware_report.delete('1.0', tk.END)
            update_report(malware_report, report_content)
        except Exception as e:
            messagebox.showerror("Eroare", f"Eroare la analiza Malware: {str(e)}")
    else:
        messagebox.showinfo("Info", "Vă rugăm să încărcați o imagine mai întâi.")

analyze_malware_button = tk.Button(tab_malware, text="Analizează Malware", command=perform_malware_analysis)
analyze_malware_button.pack(pady=5)

# Butoanele pentru fiecare analiză

load_button = tk.Button(tab_load, text="Încarcă Imagine", command=load_image)
load_button.pack(pady=5)
tk.Button(tab_LSB, text="Analizează LSB", command=lambda: analyze_LSB(panel.file_path)).pack(pady=5)
tk.Button(tab_histogram, text="Analizează Histogramă", command=lambda: analyze_histogram(panel.file_path)).pack(pady=5)
tk.Button(tab_fourier, text="Analizează Fourier", command=lambda: fourier_analysis(panel.file_path)).pack(pady=5)
tk.Button(tab_wavelet, text="Analizează Wavelet", command=lambda: wavelet_analysis(panel.file_path)).pack(pady=5)
tk.Button(tab_texture, text="Analizează Textură", command=lambda: analyze_texture(panel.file_path)).pack(pady=5)
app.mainloop()
